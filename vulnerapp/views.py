from django.shortcuts import render
import requests
from django.http import JsonResponse
from django.conf import settings
from database.models import CVE, Product
from django.db.models import Count, Subquery, OuterRef
from django.shortcuts import get_object_or_404
from django.core.paginator import Paginator

def home_page(request):
    vulnerabilities = CVE.objects.all().order_by('-release_date')[:20]
    return render(request, 'home.html', {'vulnerabilities': vulnerabilities})

def all_page(request):
    year = request.GET.get('year')
    vulnerabilities_list = CVE.objects.all()

    years = vulnerabilities_list.dates('release_date', 'year').reverse()
    if year:
        vulnerabilities_list = vulnerabilities_list.filter(release_date__year=year)

    paginator = Paginator(vulnerabilities_list, 20)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)

    return render(request, 'all.html', {'page_obj': page_obj, 'years': years})

def details_page(request, cve_id):
	cve = CVE.objects.get(id=cve_id)

	# Récupérer l'ID NVD de la CVE pour rechercher les exploits
	nvd_id = None
	if len(cve.data_sources.all()) > 0:
		for link in cve.data_sources.all():
			if link.name == "NVD":
				nvd_id = link.external_id

	# Récupérer les exploits de la CVE
	exploits = None
	if nvd_id:
		headers = {
		    "accept": "application/json, text/javascript, */*; q=0.01",
		    "accept-language": "fr-FR,fr;q=0.8",
		    "cache-control": "no-cache",
		    "pragma": "no-cache",
		    "sec-ch-ua": "\"Chromium\";v=\"122\", \"Not(A:Brand\";v=\"24\", \"Brave\";v=\"122\"",
		    "sec-ch-ua-mobile": "?0",
		    "sec-ch-ua-platform": "\"Windows\"",
		    "sec-fetch-dest": "empty",
		    "sec-fetch-mode": "cors",
		    "sec-fetch-site": "same-origin",
		    "sec-gpc": "1",
		    "x-requested-with": "XMLHttpRequest"
		}

		response = requests.get(f"https://www.exploit-db.com/search?cve={nvd_id}&draw=1&columns%5B0%5D%5Bdata%5D=date_published&columns%5B0%5D%5Bname%5D=date_published&columns%5B0%5D%5Bsearchable%5D=true&columns%5B0%5D%5Borderable%5D=true&columns%5B0%5D%5Bsearch%5D%5Bvalue%5D=&columns%5B0%5D%5Bsearch%5D%5Bregex%5D=false&columns%5B1%5D%5Bdata%5D=download&columns%5B1%5D%5Bname%5D=download&columns%5B1%5D%5Bsearchable%5D=false&columns%5B1%5D%5Borderable%5D=false&columns%5B1%5D%5Bsearch%5D%5Bvalue%5D=&columns%5B1%5D%5Bsearch%5D%5Bregex%5D=false&columns%5B2%5D%5Bdata%5D=application_md5&columns%5B2%5D%5Bname%5D=application_md5&columns%5B2%5D%5Bsearchable%5D=true&columns%5B2%5D%5Borderable%5D=false&columns%5B2%5D%5Bsearch%5D%5Bvalue%5D=&columns%5B2%5D%5Bsearch%5D%5Bregex%5D=false&columns%5B3%5D%5Bdata%5D=verified&columns%5B3%5D%5Bname%5D=verified&columns%5B3%5D%5Bsearchable%5D=true&columns%5B3%5D%5Borderable%5D=false&columns%5B3%5D%5Bsearch%5D%5Bvalue%5D=&columns%5B3%5D%5Bsearch%5D%5Bregex%5D=false&columns%5B4%5D%5Bdata%5D=description&columns%5B4%5D%5Bname%5D=description&columns%5B4%5D%5Bsearchable%5D=true&columns%5B4%5D%5Borderable%5D=false&columns%5B4%5D%5Bsearch%5D%5Bvalue%5D=&columns%5B4%5D%5Bsearch%5D%5Bregex%5D=false&columns%5B5%5D%5Bdata%5D=type_id&columns%5B5%5D%5Bname%5D=type_id&columns%5B5%5D%5Bsearchable%5D=true&columns%5B5%5D%5Borderable%5D=false&columns%5B5%5D%5Bsearch%5D%5Bvalue%5D=&columns%5B5%5D%5Bsearch%5D%5Bregex%5D=false&columns%5B6%5D%5Bdata%5D=platform_id&columns%5B6%5D%5Bname%5D=platform_id&columns%5B6%5D%5Bsearchable%5D=true&columns%5B6%5D%5Borderable%5D=false&columns%5B6%5D%5Bsearch%5D%5Bvalue%5D=&columns%5B6%5D%5Bsearch%5D%5Bregex%5D=false&columns%5B7%5D%5Bdata%5D=author_id&columns%5B7%5D%5Bname%5D=author_id&columns%5B7%5D%5Bsearchable%5D=false&columns%5B7%5D%5Borderable%5D=false&columns%5B7%5D%5Bsearch%5D%5Bvalue%5D=&columns%5B7%5D%5Bsearch%5D%5Bregex%5D=false&order%5B0%5D%5Bcolumn%5D=0&order%5B0%5D%5Bdir%5D=desc&start=0&length=15&search%5Bvalue%5D=&search%5Bregex%5D=false&_=1710880191484", headers=headers)

		if response.status_code == 200:
			exploits = response.json()
			print(exploits)
		else:
			print(response.status_code)

	return render(request, 'details.html', {'cve': cve, 'exploits': exploits})

def vendors_page(request):
	search_query = request.GET.get('search', '')

	vendors = Product.objects.filter(vendor__icontains=search_query).values('vendor').annotate(
		product_count=Count('id')
	)
	vendors = vendors.annotate(
		cve_count=Count('cve', distinct=True)
	)

	paginator = Paginator(vendors, 20)
	page_number = request.GET.get('page')
	page_obj = paginator.get_page(page_number)

	return render(request, 'home_vendors.html', {'page_obj': page_obj})

def vendor_details_page(request, vendor_name: str):
    cves = CVE.objects.filter(affected_products__vendor=vendor_name).distinct().order_by('-release_date')

    # Obtenez une liste de tous les vendeurs, triés par le nombre de CVE associées
    vendors = Product.objects.values('vendor').annotate(
        cve_count=Count('cve', distinct=True)
    ).order_by('-cve_count')

    # Convertir le queryset en une liste de dictionnaires pour pouvoir utiliser la méthode index
    vendors_list = list(vendors)

    # Trouver l'index du vendeur actuel dans la liste, qui sera son rang
    vendor_rank = next((index for (index, d) in enumerate(vendors_list) if d["vendor"] == vendor_name), None)

    return render(request, 'vendor_detail.html', {'cves': cves, "vendor_name": vendor_name, "vendor_rank": vendor_rank + 1 if vendor_rank is not None else None, "vendors_count": len(vendors_list)})


def search_page(request):
    query = request.GET.get('q')
    # Récupère les produits qui contiennent le query dans leur modèle ou vendor
    products = Product.objects.filter(model__icontains=query) | Product.objects.filter(vendor__icontains=query)
    # Regroupe par product et compte le nombre de cve_id
    products = products.values('cve_id').distinct()

    # Récupère les cves qui contiennent le query dans leur titre ou dans leur description ou dans leur produit
    cves = CVE.objects.filter(title__icontains=query) | CVE.objects.filter(description__icontains=query) | CVE.objects.filter(affected_products__in=products)
    cves = cves.distinct().order_by('-release_date')

    return render(request, 'search.html', {'cves': cves, 'query': query})