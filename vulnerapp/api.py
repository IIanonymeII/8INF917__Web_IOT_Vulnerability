from django.http import JsonResponse
from django.db.models import Count
from django.db.models.functions import Lower
from django.forms.models import model_to_dict
from database.models import CVE, Product

from django.db.models import Q

def apply_filters_and_search(queryset, request, default_order_attr, search_fields):
    # Get the order and direction from the GET parameters
    order = request.GET.get('order', default_order_attr)
    _dir = request.GET.get('dir', '')

    # If the direction is 'desc', add a '-' to the order
    if _dir == 'desc':
        order = '-' + order

    # Get the search parameter from the GET parameters
    search = request.GET.get('search', None)

    # If the search parameter is present, filter the queryset
    if search is not None:
        # Create a Q object for each search field
        queries = [Q(**{f'{field}__icontains': search}) for field in search_fields]
        # Create a single Q object by ORing the queries
        query = queries.pop()
        for item in queries:
            query |= item
        # Filter the queryset
        queryset = queryset.filter(query)

    # Order the queryset
    queryset = queryset.order_by(order)

    return queryset


def apply_pagination(queryset, request):
    # Get the page number from the GET parameters
    page = int(request.GET.get('page', 0))
    limit = int(request.GET.get('limit', 10))  # default limit is 10
    start = page * limit
    end = start + limit

    # Slice the queryset
    queryset = queryset[start:end]

    return queryset

def all(request):
    # Get the list of vulnerabilities
    vulnerabilities_list = CVE.objects.all()

    # Apply filters and search
    vulnerabilities_list_all = apply_filters_and_search(vulnerabilities_list, request, '-last_updated', ['title', 'description'])

    # Apply pagination
    vulnerabilities_list = apply_pagination(vulnerabilities_list_all, request)

    # Annotate with number of devices affected
    vulnerabilities_list = vulnerabilities_list.annotate(
        devices_affected=Count('affected_products')
    )

    # Convert the QuerySet to a list of dictionaries
    vulnerabilities_list_json = [model_to_dict(item) for item in vulnerabilities_list]

    # Add the annotations to the dictionaries
    for item, item_json in zip(vulnerabilities_list, vulnerabilities_list_json):
        item_json['devices_affected'] = item.devices_affected

    # Wrap the data in a dictionary under the "data" key
    response_data = {
        "data": vulnerabilities_list_json,
        "total": len(vulnerabilities_list_all),
    }

    return JsonResponse(response_data, safe=False)

def vendors(request):
    # Get a list of all vendors, sorted by the number of associated CVEs
    vendors = Product.objects.values('vendor').exclude(
        Q(vendor__exact="") | Q(vendor__regex=r'^\d')
    ).annotate(
        cve_count=Count('cve', distinct=True)
    )

    # Apply filters and search
    vendors_all = apply_filters_and_search(vendors, request, 'vendor', ['vendor'])

    # Apply pagination
    vendors = apply_pagination(vendors_all, request)

    # Convert the queryset into a list of dictionaries to be able to use the index method
    vendors_list = list(vendors)

    # Wrap the data in a dictionary under the "data" key
    response_data = {
        "data": vendors_list,
        "total": len(vendors_all),
    }

    return JsonResponse(response_data, safe=False)

def vendor_details(request, vendor_name):
     #  Get the vendor with the given id
    vendor = Product.objects.filter(vendor=vendor_name).first()

    # If the vendor does not exist, return a 404 response
    if vendor is None:
        return JsonResponse({"error": "Vendor not found"}, status=404)

    # Get the CVEs associated with this vendor
    cves = CVE.objects.filter(affected_products__vendor=vendor.vendor)

    # Apply filters and search
    cves_all = apply_filters_and_search(cves, request, '-last_updated', ['title', 'description'])

    # Apply pagination
    cves = apply_pagination(cves_all, request)

    # Annotate with number of devices affected
    cves = cves.annotate(
        devices_affected=Count('affected_products')
    )

    # Convert the QuerySet to a list of dictionaries
    cves_json = [model_to_dict(item) for item in cves]

    # Add the annotations to the dictionaries
    for item, item_json in zip(cves, cves_json):
        item_json['devices_affected'] = item.devices_affected

    # Wrap the data in a dictionary under the "data" key
    response_data = {
        "data": cves_json,
        "total": len(cves_json),
    }

    return JsonResponse(response_data, safe=False)