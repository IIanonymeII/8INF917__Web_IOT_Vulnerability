from django.shortcuts import render

import traceback
import json
import requests
from datetime import datetime
from django.http import JsonResponse
from django.utils import timezone
from django.db import transaction

from .models import *

UPDATE_LIMIT_ONE_FETCH = True # Limit the number of API page fetch from one to another by using the "next" field in the JSON response to 1 or not.


def fetch_data(url):
    print("Fetching " + url + "...")
    response = requests.get(url)
    response.raise_for_status()

    data = response.content.decode("utf-8")
    data = json.loads(data)

    return data


def parse_date(release_date_str):
    try:
        # Try parsing with fractional seconds and timezone
        release_date = datetime.strptime(release_date_str, "%Y-%m-%dT%H:%M:%S.%fZ")
    except ValueError:
        try:
            # If parsing with fractional seconds fails, try without
            release_date = datetime.strptime(release_date_str, "%Y-%m-%dT%H:%M:%S")
        except ValueError:
            # If parsing without fractional seconds fails, try without timezone
            release_date = datetime.strptime(release_date_str, "%Y-%m-%dT%H:%M:%SZ")
    return release_date


def process_data(data, title="", isList=True):
    try:
        cve_list = []
        product_list = []
        data_source_list = []
        patch_list = []

        for cve in data["results"] if isList else [data]:
            if "sources_release_date" in cve:
                release_date_str = cve["sources_release_date"]["data"][0]["date"]
                release_date = parse_date(release_date_str)
                release_date = timezone.make_aware(release_date)
            else:
                release_date = timezone.now()

            last_updated_str = cve["last_update_date"]
            last_updated = parse_date(last_updated_str)  # parse the date string into a datetime object
            last_updated = timezone.make_aware(last_updated)  # make it offset-aware
            severity = (
                cve["cvss"]["data"][0]["severity"][0]["value"]
                if "cvss" in cve
                else "N/A"
            )

            cve_obj, created = CVE.objects.get_or_create(
                id=cve["id"],
                defaults={
                    "description": cve["description"]["data"]
                    if "description" in cve
                    else "N/A",
                    "title": cve["title"]["data"] if "title" in cve else "N/A",
                    "type": cve["type"]["data"] if "type" in cve else "N/A",
                    "last_updated": last_updated,
                    "release_date": release_date,
                    "severity": severity,
                },
            )

            if not created and cve_obj.last_updated < last_updated:
                cve_obj.description = (
                    cve["description"]["data"] if "description" in cve else "N/A"
                )
                cve_obj.title = cve["title"]["data"] if "title" in cve else "N/A"
                cve_obj.type = cve["type"]["data"] if "type" in cve else "N/A"
                cve_obj.last_updated = last_updated
                cve_obj.release_date = release_date
                cve_obj.severity = severity
                cve_obj.save()

            # Rest of the code...

        with transaction.atomic():
            CVE.objects.bulk_create(cve_list)
            Product.objects.bulk_create(product_list)
            DataSources.objects.bulk_create(data_source_list)
            Patch.objects.bulk_create(patch_list)

        if not UPDATE_LIMIT_ONE_FETCH and "next" in data and data["next"] is not None:
            print(title + " " + "Fetching next page...")
            process_data(fetch_data(data["next"]), title, isList)
        else:
#             print(title + " " + "Finished processing data")
            pass
    except Exception as e:
        # Database locked error
        if "database is locked" in str(e):
            print(title + " " + "Database locked, retrying...")
            process_data(data, title, isList)
        else:
            traceback.print_exc()


def update_database(offset=0, thread_name=""):
    try:
        process_data(
            fetch_data(
                "https://www.variotdbs.pl/api/vulns/?format=json&limit=1000&offset="
                + str(offset)
            ),
            thread_name,
        )
        # 		process_data(fetch_data('https://www.variotdbs.pl/api/vuln/VAR-201704-0497/?format=json'), "", False)
        return JsonResponse({"status": "ok"})

    except Exception as e:
        return JsonResponse(
            {"error": "An unexpected error occurred: {}".format(str(e))}, status=500
        )
